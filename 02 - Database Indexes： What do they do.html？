<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Database Internals Masterclass | Full Transcript Revision</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body { font-family: 'Inter', sans-serif; background:#f1f5f9; color:#0f172a; scroll-behavior: smooth; }
    code { font-family:'Fira Code', monospace; background:#e2e8f0; padding:2px 6px; border-radius:4px; font-size: 0.9em; }
    .card { background:white; border-radius:24px; padding:3rem; shadow-sm: 0 4px 6px -1px rgb(0 0 0 / 0.1); margin-bottom:3rem; border: 1px solid #e2e8f0; }
    .badge { background:#1e1b4b; color:#e0e7ff; padding:6px 16px; border-radius:999px; font-size:11px; font-weight:800; letter-spacing:1.5px; text-transform: uppercase; }
    .transcript-segment { border-left: 4px solid #6366f1; background: #f8fafc; padding: 1.5rem; border-radius: 0 12px 12px 0; margin-bottom: 2rem; }
    .architect-deep-dive { background: #fdf2f8; border: 1px solid #fce7f3; padding: 2rem; border-radius: 16px; }
    .example-box { background: #f0fdf4; border: 1px solid #dcfce7; padding: 1rem; border-radius: 8px; margin-top: 1rem; }
    .scan-table td, .scan-table th { border: 1px solid #e2e8f0; padding: 0.75rem; text-align: left; font-size: 0.85rem; }
    .raw-transcript { background: #1e293b; color: #94a3b8; font-family: 'Fira Code', monospace; font-size: 0.75rem; padding: 2rem; border-radius: 12px; max-height: 400px; overflow-y: auto; line-height: 1.6; }
  </style>
</head>
<body>

<main class="max-w-5xl mx-auto px-6 py-16">

  <!-- HERO SECTION -->
  <header class="mb-12 text-center">
    <h1 class="text-5xl font-black text-slate-900 mb-4 tracking-tight">Database Internals Masterclass</h1>
    <p class="text-xl text-slate-600 max-w-2xl mx-auto italic">"A line-by-line revision guide from raw transcript to expert architecture."</p>
  </header>

  <!-- SECTION 1: THE OPENING & PERSISTENCE -->
  <section class="card">
    <span class="badge">Part 1: The Three Facts</span>
    
    <div class="transcript-segment mt-6">
        <h3 class="text-indigo-600 font-bold mb-3 text-sm flex items-center gap-2"><i class="fas fa-quote-left"></i> TRANSCRIPT</h3>
        <p class="text-slate-800 leading-relaxed italic">
            "hey everyone and welcome back this is my second shot at recording for this series... apologies for the technical difficulties last time my iPad recording was getting turned off more frequently than my ex-girlfriend whenever I tried to make sexual advances... we established basically three facts about the data. Number one is the following that we want the data to [be persistent]. Number two is that we want to be doing this on a hard drive... RAM does not store data between computers shutting off and on... The third thing is that the hard drive is in a database or at least we're running database software on some computer."
        </p>
    </div>

    <div class="architect-deep-dive">
        <h4 class="font-black text-pink-900 mb-4 flex items-center gap-2 underline decoration-pink-300">EXPERT REVISION: THE DURABILITY PROBLEM</h4>
        <div class="space-y-4 text-slate-700 text-sm">
            <p><strong>Fact Check:</strong> Persistence is the 'P' in most architectural discussions (and the 'D' in ACID). The core challenge is that we are storing software-logical structures on physical, mechanical hardware.</p>
            <p><strong>Example:</strong> Think of <strong>RAM</strong> like a whiteboard (fast to write on, wiped at night) and a <strong>Hard Drive</strong> like a stone tablet (hard to carve, but permanent). A Database is the specialized tool used to carve and read those tablets efficiently.</p>
        </div>
        
        <div class="mt-8 bg-white p-6 rounded-xl border border-pink-100 flex flex-col items-center">
            <svg viewBox="0 0 400 150" class="w-full max-w-md">
                <rect x="50" y="50" width="120" height="60" fill="#fee2e2" stroke="#ef4444" rx="8"/>
                <text x="75" y="85" font-size="14" font-weight="bold" fill="#991b1b">RAM</text>
                <text x="65" y="100" font-size="10" fill="#b91c1c">Volatile / $O(1)$</text>
                
                <path d="M180 80 L220 80" stroke="#94a3b8" stroke-width="2" marker-end="url(#arrow)"/>
                
                <rect x="230" y="50" width="120" height="60" fill="#dcfce7" stroke="#22c55e" rx="8"/>
                <text x="255" y="85" font-size="14" font-weight="bold" fill="#166534">DISK</text>
                <text x="245" y="100" font-size="10" fill="#15803d">Persistent / $O(Disk)$</text>
            </svg>
        </div>
    </div>
  </section>

  <!-- SECTION 2: DISK LOCALITY -->
  <section class="card">
    <span class="badge">Part 2: Physical Hardware</span>
    
    <div class="transcript-segment mt-6">
        <h3 class="text-indigo-600 font-bold mb-3 text-sm flex items-center gap-2"><i class="fas fa-quote-left"></i> TRANSCRIPT</h3>
        <p class="text-slate-800 leading-relaxed italic">
            "we've got basically some rectangle with a metallic disc and then some moving arm... the closer that you put data together on disk the faster it is to access... for example if I have one piece of data here and the other here that's kind of bad... instead it would be better if we had our first piece of data here again and the second one right next to it."
        </p>
    </div>

    <div class="architect-deep-dive">
        <h4 class="font-black text-pink-900 mb-4 flex items-center gap-2 underline decoration-pink-300">EXPERT REVISION: MECHANICAL LATENCY</h4>
        <div class="space-y-4 text-sm text-slate-700">
            <p><strong>The "Moving Arm" Problem:</strong> This refers to <strong>Seek Time</strong>. Physically moving the arm takes ~5-10ms. In computer time, this is an eternity. </p>
            <div class="example-box">
                <p><strong>The Proximity Example:</strong> If "Jordan's" data is on Sector 1 and "Donald's" data is on Sector 1000, the disk arm must physically move across the platter. If they are in Sector 1 and 2, the data is read in a single "glance" as the disc spins.</p>
            </div>
        </div>
    </div>
  </section>

  <!-- SECTION 3: THE NAIVE TABLE & O(N) -->
  <section class="card">
    <span class="badge">Part 3: Complexity Analysis</span>
    
    <div class="transcript-segment mt-6">
        <h3 class="text-indigo-600 font-bold mb-3 text-sm flex items-center gap-2"><i class="fas fa-quote-left"></i> TRANSCRIPT</h3>
        <p class="text-slate-800 leading-relaxed italic">
            "let's imagine a website right where basically all it does is it stores a bunch of names... Jordan size 18... Donald... size 7... Shaq size 24. in order for me to find rows where name is Jordan I have to check each row individually... what that means... is that this is going to be an O(n) time complexity."
        </p>
    </div>

    <div class="architect-deep-dive">
        <h4 class="font-black text-pink-900 mb-4 flex items-center gap-2 underline decoration-pink-300">EXPERT REVISION: THE LINEAR SCAN</h4>
        <div class="space-y-4 text-sm text-slate-700 mb-6">
            <p><strong>Linear Search Performance:</strong> When data is unindexed, the database must perform a "Full Table Scan." Every single page on the disk must be loaded into memory and checked. Work done $\propto$ Total Rows ($N$).</p>
        </div>

        <h5 class="text-xs font-bold uppercase text-slate-500 mb-3 tracking-widest">Tabular Walkthrough: Searching for "Shaq" (Transcript Example)</h5>
        <div class="overflow-hidden rounded-xl border border-slate-200 mb-6">
            <table class="w-full scan-table">
                <thead class="bg-slate-50 text-slate-600">
                    <tr>
                        <th>Step</th>
                        <th>Disk Block</th>
                        <th>Data Found</th>
                        <th>Operation</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody class="text-slate-600">
                    <tr>
                        <td>1</td>
                        <td>0x0001</td>
                        <td>[Jordan, 18]</td>
                        <td>Check "Jordan" == "Shaq"</td>
                        <td class="text-red-500 font-bold">❌ Skip</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>0x0002</td>
                        <td>[Donald, 7]</td>
                        <td>Check "Donald" == "Shaq"</td>
                        <td class="text-red-500 font-bold">❌ Skip</td>
                    </tr>
                    <tr class="bg-emerald-50">
                        <td>3</td>
                        <td>0x0003</td>
                        <td>[Shaq, 24]</td>
                        <td>Check "Shaq" == "Shaq"</td>
                        <td class="text-emerald-600 font-bold">✅ Match</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <p class="text-[11px] text-slate-400 italic">Conclusion: In the worst case (e.g. searching for a name not in the list), we check every block in the table.</p>
    </div>
  </section>

  <!-- SECTION 4: APPEND-ONLY LOGS -->
  <section class="card">
    <span class="badge">Part 4: The Append-Only Shift</span>
    
    <div class="transcript-segment mt-6">
        <h3 class="text-indigo-600 font-bold mb-3 text-sm flex items-center gap-2"><i class="fas fa-quote-left"></i> TRANSCRIPT</h3>
        <p class="text-slate-800 leading-relaxed italic">
            "instead of actually doing any physical edits... add a new row to the table where I would now just say Donald with the new shoe size... realized now it's a six... search from the bottom of the table up... we can basically keep a pointer to that address and disk and that makes right times o of one."
        </p>
    </div>

    <div class="architect-deep-dive">
        <h4 class="font-black text-pink-900 mb-4 flex items-center gap-2 underline decoration-pink-300">EXPERT REVISION: LOG-STRUCTURED WRITES</h4>
        <div class="space-y-4 text-sm text-slate-700 mb-6">
            <p><strong>Append-Only Log:</strong> Instead of searching ($O(N)$) to find "Donald" and overwrite his size, we treat the database like a notebook where you only add lines at the bottom. This makes writes <strong>$O(1)$ Constant Time</strong>.</p>
        </div>

        <h5 class="text-xs font-bold uppercase text-slate-500 mb-3 tracking-widest">Tabular Walkthrough: Appending Donald (7 &rarr; 6)</h5>
        <div class="overflow-hidden rounded-xl border border-slate-200 mb-6">
            <table class="w-full scan-table">
                <thead class="bg-slate-50 text-slate-600">
                    <tr>
                        <th>Offset</th>
                        <th>Timestamp</th>
                        <th>Record</th>
                        <th>Logical Status</th>
                    </tr>
                </thead>
                <tbody class="text-slate-600 font-mono text-[10px]">
                    <tr class="opacity-50">
                        <td>0x001</td>
                        <td>12:00:01</td>
                        <td>[Jordan, 18]</td>
                        <td>Active</td>
                    </tr>
                    <tr class="bg-red-50 line-through text-red-400">
                        <td>0x002</td>
                        <td>12:00:05</td>
                        <td>[Donald, 7]</td>
                        <td>Obsolete (Shadowed)</td>
                    </tr>
                    <tr class="opacity-50">
                        <td>0x003</td>
                        <td>12:00:10</td>
                        <td>[Shaq, 24]</td>
                        <td>Active</td>
                    </tr>
                    <tr class="bg-emerald-50 text-emerald-900 font-bold">
                        <td>0x004</td>
                        <td>12:05:00</td>
                        <td>[Donald, 6]</td>
                        <td>Current (Latest)</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="example-box">
            <p class="text-xs font-bold text-emerald-800"><i class="fas fa-info-circle"></i> The Read Strategy:</p>
            <p class="text-xs mt-1">To find Donald's current size, the DB scans <strong>backwards</strong> from 0x004. As soon as it hits "Donald" at 0x004, it returns "6" and stops. The old "7" at 0x002 is ignored. This makes writing instant, but search still takes linear work ($O(N)$).</p>
        </div>
    </div>
  </section>

  <!-- SECTION 5: INDEXES & SCALING -->
  <section class="card">
    <span class="badge">Part 5: Scaling to Facebook</span>
    
    <div class="transcript-segment mt-6">
        <h3 class="text-indigo-600 font-bold mb-3 text-sm flex items-center gap-2"><i class="fas fa-quote-left"></i> TRANSCRIPT</h3>
        <p class="text-slate-800 leading-relaxed italic">
            "o of n reads are basically slower than Joe Biden trying to read from a teleprompter and he is a boomer... think about Facebook for example... if I have to go through every single Post in the database in order to go ahead and load our news feed that is going to be impractical... this is where the need for indexes come in... show rows with names between A and B... posts from you know one hour ago until now."
        </p>
    </div>

    <div class="architect-deep-dive">
        <h4 class="font-black text-pink-900 mb-4 flex items-center gap-2 underline decoration-pink-300">EXPERT REVISION: INDEXING & RANGE QUERIES</h4>
        <div class="space-y-4 text-sm text-slate-700">
            <p><strong>The Scalability Ceiling:</strong> $O(N)$ is only fast when $N$ is small. At Facebook scale ($N = 10^{12}$ posts), linear scanning is physically impossible.</p>
            <div class="example-box bg-indigo-50 border-indigo-100">
                <p class="font-bold text-indigo-800">Range Query Example:</p>
                <p class="text-xs">"Give me names between A and B (e.g., Abraham Lincoln and Alex Adams)." <br>Without an index, you scan all 1 billion rows. With a sorted index, you jump to 'A', read until 'B', and stop.</p>
            </div>
        </div>

        <div class="mt-8 bg-slate-900 p-6 rounded-xl border-l-4 border-indigo-500">
            <h5 class="text-indigo-400 font-bold text-xs mb-2">SYSTEM DESIGN QUOTE</h5>
            <p class="text-slate-300 text-sm italic">"We care a lot more about read speeds than write speeds... indexing can help improve read speeds even if it makes writing more expensive... it's still a big win in the average case for user experience."</p>
        </div>
    </div>
  </section>

  <!-- SUMMARY SECTION -->
  <section class="card bg-slate-900 text-slate-300">
    <h2 class="text-3xl font-bold mb-8 text-white flex items-center gap-3">
        <i class="fas fa-list-check text-emerald-400"></i> Transcript Executive Summary
    </h2>
    <div class="grid md:grid-cols-2 gap-8 text-sm leading-relaxed">
        <div class="space-y-4">
            <h4 class="text-white font-bold border-b border-slate-700 pb-2">Core Mechanics</h4>
            <ul class="list-disc ml-5 space-y-2">
                <li><strong>Durability:</strong> Persistence requires writing to mechanical disks, not just volatile RAM.</li>
                <li><strong>Disk Locality:</strong> Placing data "next to each other" minimizes Arm Seek Time, which is the primary driver of performance.</li>
                <li><strong>The Array Model:</strong> Conceptualize the disk as one giant byte array where indices are offset pointers.</li>
            </ul>
        </div>
        <div class="space-y-4">
            <h4 class="text-white font-bold border-b border-slate-700 pb-2">The Trade-off Cycle</h4>
            <ul class="list-disc ml-5 space-y-2">
                <li><strong>Naive State:</strong> Both reads and writes are $O(N)$ because finding data takes linear effort.</li>
                <li><strong>The Optimization:</strong> Using <strong>Append-Only Logs</strong> converts writes to $O(1)$ by removing the "find" step.</li>
                <li><strong>The Price:</strong> Append-only logs grow $N$ faster and make $O(N)$ reads even slower over time.</li>
                <li><strong>The Solution:</strong> Database <strong>Indexes</strong> (Keys and Ranges) provide the direct jump needed for modern scale.</li>
            </ul>
        </div>
    </div>
  </section>

  <!-- RAW TRANSCRIPT SECTION -->
  <section class="card">
    <span class="badge">Raw Video Transcript</span>
    <h2 class="text-3xl font-bold mt-4 mb-6">Full Verbatim Script</h2>
    <div class="raw-transcript">
      hey everyone and welcome back this is my hey everyone and welcome back this is my second shot at recording for this series second shot at recording for this series uh apologies for the technical uh apologies for the technical difficulties last time my iPad recording difficulties last time my iPad recording was getting turned off more frequently was getting turned off more frequently than my ex-girlfriend whenever I tried than my ex-girlfriend whenever I tried to make sexual advances uh but the great to make sexual advances uh but the great thing about this series is that I can thing about this series is that I can really crank these out really crank these out um I'm not going to finish that joke off um I'm not going to finish that joke off uh because I have pretty much already uh because I have pretty much already made them all before so as you can see made them all before so as you can see I'm making my second one of the day I'm making my second one of the day which is great so um you know if you which is great so um you know if you recall from last time we started to get recall from last time we started to get into the contextualization of the into the contextualization of the database problem how we want to actually database problem how we want to actually organize our data that we can read fast organize our data that we can read fast write fast keep it persistent and so write fast keep it persistent and so today what we're going to do is take a today what we're going to do is take a look at the actual internals of a look at the actual internals of a database and how we want to put our data database and how we want to put our data on the disk in order to maximize on the disk in order to maximize performance all right welcome back performance all right welcome back everybody I have now gotten the iPad and everybody I have now gotten the iPad and I'm ready to do some work you may see I'm ready to do some work you may see this is a different day I'm just coming this is a different day I'm just coming home from the office right now and I home from the office right now and I have to take a very badly so let's have to take a very badly so let's get this is done with relatively quickly get this is done with relatively quickly so we established basically three facts so we established basically three facts about the data last video that we're about the data last video that we're first going to talk about number one is first going to talk about number one is the following that we want the data to the following that we want the data to number two number two even more importantly is that we want to even more importantly is that we want to be doing this on a hard drive that kind be doing this on a hard drive that kind of follows from persistence we know that of follows from persistence we know that RAM does not store data between RAM does not store data between computers shutting off and on so it's computers shutting off and on so it's more durable on a hard drive the third more durable on a hard drive the third thing is of course that the hard drive thing is of course that the hard drive is in a database is in a database or at least we're running database or at least we're running database software on some computer and the actual software on some computer and the actual data itself is being stored at that hard data itself is being stored at that hard drive drive drive so before we go ahead and move further so before we go ahead and move further let's go ahead and look at our hard let's go ahead and look at our hard drive in more depth so I'm going to draw drive in more depth so I'm going to draw another picture of it this time a little another picture of it this time a little bit bigger so hopefully that helps we've bit bigger so hopefully that helps we've got basically some rectangle with a got basically some rectangle with a metallic disc and then some moving arm metallic disc and then some moving arm that goes to the proper place on disk in that goes to the proper place on disk in order to read or write data so generally order to read or write data so generally the point of this is that because this the point of this is that because this little arm has to actually move around little arm has to actually move around the metallic disc the closer that you the metallic disc the closer that you put data together on disk the faster it put data together on disk the faster it is to access so for example you know if is to access so for example you know if I have one piece of data here and the I have one piece of data here and the other here that's kind of bad instead it other here that's kind of bad instead it would be better if you know we had our would be better if you know we had our first piece of data here again and the first piece of data here again and the second one right next to it second one right next to it we're more likely to get better read we're more likely to get better read speeds okay so now let's actually go speeds okay so now let's actually go ahead and start thinking about you know ahead and start thinking about you know the data is going to just look like an the data is going to just look like an array on disk right we have all of our array on disk right we have all of our little bytes that we can write down and little bytes that we can write down and slots and so again you know the closer slots and so again you know the closer the data is to one another when we want the data is to one another when we want to access it together the better so to access it together the better so that's how I'm going to preface this that's how I'm going to preface this entire lesson but we'll see this coming entire lesson but we'll see this coming to play more and more so let me go ahead to play more and more so let me go ahead and scroll down a little bit so now and scroll down a little bit so now let's imagine a website right where let's imagine a website right where basically all it does is it stores a basically all it does is it stores a bunch of names of people and their shoe bunch of names of people and their shoe sizes and every time you load up the sizes and every time you load up the website it'll show you all those people website it'll show you all those people and their shoe sizes so I'm now going to and their shoe sizes so I'm now going to draw up an example database table for draw up an example database table for this website so you can see we're going this website so you can see we're going to have a few rows of people and their to have a few rows of people and their respective shoe size so the first person respective shoe size so the first person is going to be me Jordan is going to be me Jordan uh and you know my shoe size is 18 uh and you know my shoe size is 18 because you know big shoes means quite a because you know big shoes means quite a little bit about what else is going on little bit about what else is going on in your body and we know that uh in your body and we know that uh unpacking number two is going to be unpacking number two is going to be Donald Donald Donald for Trump he has small hands so he for Trump he has small hands so he probably has small shoes as well we're probably has small shoes as well we're gonna go ahead and throw him a seven and gonna go ahead and throw him a seven and then we've got Shaq for Shaquille O'Neal then we've got Shaq for Shaquille O'Neal that dude is massive probably has like a that dude is massive probably has like a size 24. I can concede to Shaq so what size 24. I can concede to Shaq so what is my point about this table well the is my point about this table well the first thing is let's say I want to find first thing is let's say I want to find rows rows rows where name is Jordan where name is Jordan this is something you can do in most this is something you can do in most databases databases databases right in order for me to go ahead and do right in order for me to go ahead and do that I have to check each row that I have to check each row individually I have to go here then row individually I have to go here then row number two then row number three and number two then row number three and what that means when you have to do what that means when you have to do proportional work to the number of rows proportional work to the number of rows in the actual table itself is that this in the actual table itself is that this is going to be an O of n time complexity is going to be an O of n time complexity right if there are n rows we have to do right if there are n rows we have to do n amounts of work basically or work n amounts of work basically or work proportional to the N rows in order to proportional to the N rows in order to actually find the row that we care about actually find the row that we care about so in addition to that let's say I so in addition to that let's say I wanted to actually edit a size turns out wanted to actually edit a size turns out Shaq is bigger than we thought his shoe Shaq is bigger than we thought his shoe size is actually going to be 26. so size is actually going to be 26. so again if we're going to write first what again if we're going to write first what that means is that we have to actually that means is that we have to actually find the proper row right we're going find the proper row right we're going all the way through these rows again and all the way through these rows again and then we're going and changing our then we're going and changing our existing Row from a 24 to a 26. so that existing Row from a 24 to a 26. so that means o of n time complexity for both means o of n time complexity for both reads reads reads and writes and writes okay so let me quickly erase this 26 okay so let me quickly erase this 26 and throw back our 24 because what I'm and throw back our 24 because what I'm now going to show is a slightly better now going to show is a slightly better design of a database table that would design of a database table that would basically allow us to improve at least basically allow us to improve at least our right complexity our right complexity so let's say this time instead of so let's say this time instead of editing Shack I want to edit Donald so editing Shack I want to edit Donald so we knew normally that in order to make we knew normally that in order to make that edit we would actually have to find that edit we would actually have to find the road Donald in the table and edit it the road Donald in the table and edit it but now what I'm proposing is instead of but now what I'm proposing is instead of actually doing any physical edits what actually doing any physical edits what we do instead sorry I don't know how to we do instead sorry I don't know how to use this iPad yet is we would go ahead use this iPad yet is we would go ahead and add a new row to the table and add a new row to the table where I would now just say Donald where I would now just say Donald with the new shoe size let's say his with the new shoe size let's say his foot is actually even smaller than we foot is actually even smaller than we realized now it's a six and then every realized now it's a six and then every time we search for a row now we actually time we search for a row now we actually just go ahead and search from the bottom just go ahead and search from the bottom of the table up so in the case of Donald of the table up so in the case of Donald I would say oh it's got to be this row I would say oh it's got to be this row here not this one because this Donald is here not this one because this Donald is actually lower to the bottom and so now actually lower to the bottom and so now because we know that we're always going because we know that we're always going to be writing in the same place every to be writing in the same place every time which is the bottom of the table we time which is the bottom of the table we can basically keep a pointer to that can basically keep a pointer to that address and disk and that makes right address and disk and that makes right times o of one times o of one uh however this does come on the uh however this does come on the trade-off of a worse read time the trade-off of a worse read time the reason for that is that even though reason for that is that even though reads are still o of n reads are still o of n it means that uh they're going to it means that uh they're going to actually be more rows in the table actually be more rows in the table overall so that n is going to be bigger overall so that n is going to be bigger obviously this isn't going to be obviously this isn't going to be acceptable as o of n reads are basically acceptable as o of n reads are basically slower than Joe Biden trying to read slower than Joe Biden trying to read from a teleprompter and he is a boomer from a teleprompter and he is a boomer so it's not ideal but the truth of the so it's not ideal but the truth of the matter is actually in a lot of these matter is actually in a lot of these problems or a lot of these big websites problems or a lot of these big websites We Care a lot more about read speeds We Care a lot more about read speeds than write speeds and at least as far as than write speeds and at least as far as I've just showed you those read speeds I've just showed you those read speeds were pretty unacceptable o within is not were pretty unacceptable o within is not good enough right we're going to cross good enough right we're going to cross that out just go ahead and say it right that out just go ahead and say it right there the reason o of n isn't good there the reason o of n isn't good enough is because when we have hundreds enough is because when we have hundreds of thousands or even millions or of thousands or even millions or possibly more rows in our database we possibly more rows in our database we don't want to have to literally Loop don't want to have to literally Loop through every single one in order to through every single one in order to find the proper row that we want we need find the proper row that we want we need to make things faster than that think to make things faster than that think about Facebook for example about Facebook for example all right this is the example I keep all right this is the example I keep using if I have to go through every using if I have to go through every single Post in the database in order to single Post in the database in order to go ahead and load our news feed that is go ahead and load our news feed that is going to be impractical and it simply going to be impractical and it simply doesn't make sense we need a better way doesn't make sense we need a better way and this is where the need for indexes and this is where the need for indexes come in come in so before I actually explain what an so before I actually explain what an index is let's think about some things index is let's think about some things that an index or just a better way of that an index or just a better way of reading from databases in general could reading from databases in general could help us do well for one we care about help us do well for one we care about finding rows finding rows with specific key values right so in the with specific key values right so in the last example last example uh basically that was finding a row by a uh basically that was finding a row by a name name name sorry I can't write terrible handwriting sorry I can't write terrible handwriting in the last example it was finding a in the last example it was finding a specific row with a name that matched specific row with a name that matched the parameter that I provided but in the parameter that I provided but in another example you know maybe it could another example you know maybe it could be names maybe we care about finding a be names maybe we care about finding a row with a specific shoe size that could row with a specific shoe size that could help as well and we want to be able to help as well and we want to be able to do this faster than just by linearly do this faster than just by linearly scanning through that whole table scanning through that whole table another possibility another possibility is performing something known as a range is performing something known as a range query query query so we gave some names before an example so we gave some names before an example of a range query would be show of a range query would be show rows rows rows with with with names names names between A and B A and B right right right so so so if they're you know Abraham Lincoln in if they're you know Abraham Lincoln in there you know Alex Adams anyone like there you know Alex Adams anyone like that you want to go ahead and return all that you want to go ahead and return all and this is a very common query if you and this is a very common query if you think about it in something like a think about it in something like a social media site maybe we want all social media site maybe we want all posts from you know one hour ago until posts from you know one hour ago until now right so it's basically any sort of now right so it's basically any sort of range query where we have these kind of range query where we have these kind of two delimiting parameters and we two delimiting parameters and we ultimately want to get every single ultimately want to get every single thing in between so these are very thing in between so these are very common cases where we care about common cases where we care about optimizing them even if it means optimizing them even if it means potentially taking a penalty in our potentially taking a penalty in our write speeds right because at the end of write speeds right because at the end of the day if we're doing a lot more the day if we're doing a lot more reading than writing something in the reading than writing something in the database that can help us improve our database that can help us improve our read speeds even if it makes writing read speeds even if it makes writing more expensive is still going to be a more expensive is still going to be a big win in the average case for the user big win in the average case for the user experience experience experience and so ultimately what we want is going and so ultimately what we want is going to be called a database index a database to be called a database index a database index like I've started to hint at index like I've started to hint at basically does the following basically basically does the following basically does The Following does The Following the read speeds the read speeds go up go up go down and this is for a specific key go down and this is for a specific key right so we can have a database index on right so we can have a database index on one field for example like names in that one field for example like names in that table but you know when you mention an table but you know when you mention an index typically it is on one field at a index typically it is on one field at a time you can create multiple indexes time you can create multiple indexes where there is an index on both the name where there is an index on both the name and the shoe size you could even and the shoe size you could even potentially have an index on both the potentially have an index on both the name and the shoe size but we'll kind name and the shoe size but we'll kind explain what all of that is in the next explain what all of that is in the next video where I am going to show you one video where I am going to show you one example of how to implement an index and example of how to implement an index and kind of the pitfalls and the benefits of kind of the pitfalls and the benefits of that specific implementation which is that specific implementation which is going to be a hash index going to be a hash index all right everybody thanks again for all all right everybody thanks again for all the support on the first video of this the support on the first video of this series again I'm sorry about the series again I'm sorry about the flickering but uh hopefully we can get flickering but uh hopefully we can get that fixed up this time around I am now that fixed up this time around I am now going to go ahead and take a fat crap going to go ahead and take a fat crap
    </div>
  </section>

  <footer class="text-center text-slate-500 py-12">
    <p>Next Up: <strong>Hash Indexes Deep Dive</strong></p>
  </footer>

</main>

<script>
    console.log("Transcript Revision System: Online.");
</script>

</body>
</html>
